# 文件名: .github/workflows/convert.yml (API 直连最终版)

name: Convert Gist YAML to Surge Format

on:
  schedule:
    - cron: '0 */4 * * *'
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    env:
      GIST_ID: "41d83386c3f8a59a928e74c78d48cef1"
      YAML_FILENAME: "all.yaml"
      SURGE_FILENAME: "surge_config.txt"
      GITHUB_TOKEN: ${{ secrets.GIST_TOKEN }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          pip install pyyaml
          # jq 是一个处理 JSON 的强大工具，GitHub Actions Runner 自带，无需安装
          # 但为了保险起见，可以加上 sudo apt-get install -y jq

      - name: Fetch and Convert
        run: |
          # 1. 可靠地获取 Gist 文件的下载 URL
          YAML_URL=$(gh api "gists/${{ env.GIST_ID }}" --jq ".files[\"${{ env.YAML_FILENAME }}\"].raw_url")
          if [ -z "$YAML_URL" ] || [ "$YAML_URL" == "null" ]; then
            echo "Error: Could not find file '${{ env.YAML_FILENAME }}' in Gist or get its URL."
            exit 1
          fi
          
          # 2. 下载文件内容
          YAML_CONTENT=$(curl -sL "$YAML_URL")

          # 3. 创建 Python 转换脚本文件
          cat << 'EOF' > converter.py
          import yaml, sys
          def parse_proxy(proxy):
              if not proxy or not isinstance(proxy, dict): return None
              proxy_type = proxy.get('type')
              if not proxy_type: return None
              name = proxy.get('name', 'Unnamed')
              params = [proxy_type, str(proxy.get('server', '')), str(proxy.get('port', ''))]
              if proxy_type == 'trojan':
                  params.append(f"password={proxy.get('password', '')}")
              elif proxy_type in ['vless', 'vmess']:
                  params.append(f"uuid={proxy.get('uuid', '')}")
                  if proxy_type == 'vmess': params.append(f"alterId={proxy.get('alterId', '0')}")
              elif proxy_type == 'hysteria2':
                  auth_pass = proxy.get('password') or proxy.get('auth') or proxy.get('auth-str') or ""
                  params.append(f"password={auth_pass}")
              if proxy.get('network') == 'ws':
                  params.append('ws=true')
                  ws_opts = proxy.get('ws-opts', {})
                  ws_path = ws_opts.get('path', '/')
                  params.append(f'ws-path={ws_path}')
                  if 'headers' in ws_opts and 'Host' in ws_opts['headers']:
                      host = ws_opts['headers']['Host']
                      params.append(f'ws-headers=Host:{host}')
              if proxy.get('tls', False): params.append('tls=true')
              sni = proxy.get('sni') or proxy.get('servername')
              if sni: params.append(f'sni={sni}')
              if proxy.get('skip-cert-verify', False): params.append('skip-cert-verify=true')
              return f"{name} = {','.join(params)}"
          def main():
              yaml_content = sys.stdin.read()
              if not yaml_content: return
              try:
                  data = yaml.safe_load(yaml_content)
                  if 'proxies' not in data or not isinstance(data.get('proxies'), list): return
                  for proxy in data['proxies']:
                      if proxy:
                          surge_line = parse_proxy(proxy)
                          if surge_line: print(surge_line)
              except Exception as e:
                  print(f'Error processing YAML: {e}', file=sys.stderr)
                  sys.exit(1)
          if __name__ == '__main__': main()
          EOF

          # 4. 执行转换，并直接生成我们想要的最终文件名
          echo "$YAML_CONTENT" | python converter.py > ${{ env.SURGE_FILENAME }}
          echo "Conversion successful. Created local file: ${{ env.SURGE_FILENAME }}"

      # ##################################################################
      # 最终解决方案：直接调用 GitHub API 来更新 Gist
      # ##################################################################
      - name: Update Gist using GitHub API
        run: |
          # 1. 将文件内容读入一个变量
          FILE_CONTENT=$(cat ${{ env.SURGE_FILENAME }})

          # 2. 使用 jq 工具将文件内容安全地转换为 JSON 字符串格式 (处理引号、换行等)
          # -R 表示读取原始字符串, -s 表示将所有输入合并成一个单一的字符串
          JSON_CONTENT=$(jq -R -s . ${{ env.SURGE_FILENAME }})

          # 3. 构建 API 请求的 JSON 主体
          # 格式为：{"files": {"你的文件名": {"content": "你的文件内容"}}}
          JSON_PAYLOAD=$(printf '{"files":{"%s":{"content":%s}}}' "${{ env.SURGE_FILENAME }}" "$JSON_CONTENT")
          
          echo "Updating Gist with new content..."
          # 4. 使用 gh api 发送 PATCH 请求来更新 Gist
          # --method PATCH: 指定 HTTP 方法
          # --input -: 表示从标准输入读取请求的主体
          echo "$JSON_PAYLOAD" | gh api \
            --method PATCH \
            "/gists/${{ env.GIST_ID }}" \
            --input -
            
          echo "Gist update completed successfully."
